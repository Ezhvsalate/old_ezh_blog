<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Записная книжка ежа - Основы анализа безопасности веб-проектов</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css"/>
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link href="https://fonts.googleapis.com/css?family=Exo+2" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./theme/css/main.css"/>
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/zenburn.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

<meta name="tags" content="security" />
</head>
<body>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }

    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style><div id="container">
    <header>
        <h1 style="margin-bottom: 0"><a href="../"><img src="./theme/images/logo3.svg" style="width: 120px; box-shadow: None;" alt="logo"/> Записная книжка ежа</a></h1>
        <ul class="social-media">
            <li><a href="https://github.com/Ezhvsalate"><i class="fa fa-github fa-lg" aria-hidden="true"></i></a></li>
        </ul>
        <!--        <p style="margin-top: 0; margin-left: 120px;"><em>Еж иголки спрятатать не может</em></p>-->
    </header>
    <nav>
        <ul>
            <li><a                    class="active" href="../category/posty.html"> Посты </a></li>
            <li><a href="../about">О блоге</a>
            </li>
        </ul>
    </nav>
<main>
    <article>
        <h2>Основы анализа безопасности веб-проектов</h2>
        
        <aside>
            <ul>
                <li>
                    Опубликовано: <time datetime="2018-01-14 20:12:29+03:00">14 янв 2018</time>
                </li>
                <li>Время прочтения: 3 мин</li>
                <li>
                    Tags:
                    <a href="../tag/security.html"><em>#security</em></a>
                </li>
            </ul>
        </aside>
        
<p>Совсем недавно прошел на платформе Stepik <a href="https://stepik.org/course/127/syllabus">курс &quot;Анализ безопасности веб-проектов&quot;</a>, от mail.ru. Этот пост представляет собой что-то
    вроде конспекта курса, который писался по мере прохождения, для того, чтобы проще было систематизировать информацию и обращаться к ней спустя какое-то время. Помимо содержимого курса, старался
    дополнять материал ссылками на показавшиеся интересными и полезными статьи/ресурсы для более глубокого знакомства с темой.</p>

<p>Общий подход курса - посмотреть на целевую систему со стороны злоумышленника. Для этого выделена определенная последовательность шагов - сбор информации, обзор возможных точек входа в целевую
    систему, поиск веб-уязвимостей, поиск уязвимостей со стороны клиента, пост-эксплуатация найденных уязвимостей.</p>

<p>В курсе освещаются (поверхностно, но достаточно, для общего понимания принципов и возможности углубиться самостоятельно) такие уязвимости и направления атаки, как локальное включение данных,
    инъекция команд, SQL-инъекции, CSRF, XSS и другие.</p>

<p>Перед тем, как перейти к основной части конспекта - хотелось бы оговорить две вещи:</p>

<ol>
    <li>чтение данного поста не заменит прохождение самого курса, т.к. в нем есть весьма и весьма интересные задачи.</li>
    <li>если вы - автор/правообладатель курса и вы против публикации такого рода конспекта - напишите <a href="mailto:ezhvsalate@yandex.ru">сюда</a>.</li>
</ol>

<h2><a id="ch1">Сбор информации</a></h2>

<p>Для любой системы есть некая точка входа. Такой точкой может быть url-адрес, ip-адрес компьютера и т.п. Изначально мы должны постараться максимально расширить поверхность атаки, т.е. если точка
    входа - некое доменное имя - стоит узнать об имеющихся поддоменах, других доменах, принадлежащих той же организации и т.п. И если у первоначальной точки входа не было уязвимостей, возможно их
    удастся найти в других точках, входящих в поверхность атаки.</p>

<p>Для получения первоначальной информации о цели есть две группы методов: пассивный анализ и активный анализ.</p>

<ul>
    <li>При пассивном анализе используются только общедоступные методы, &quot;никто ничего не нарушает&quot;.</li>
    <li>Активный анализ может в том или ином виде спровоцировать реакцию системы безопасности целевой системы.</li>
</ul>

<p>В пассивном анализе рассматриваются:</p>

<ol>
    <li>Использование данных, получаемых через систему доменных имен (DNS, WhoIs)</li>
    <li>Поисковые системы</li>
    <li>Код клиентской части</li>
    <li>Содержимое robots.txt</li>
    <li>Используемые компоненты</li>
    <li>Социальные сети</li>
</ol>

<p>Все это может дать некоторую информацию о цели</p>

<p>В ходе активного анализа рассматриваются:</p>

<ol>
    <li>Подбор DNS-записей</li>
    <li>Подбор файловых путей</li>
    <li>Подбор пользователей</li>
    <li>Сканирование портов</li>
</ol>

<h3>DNS и Zonetransfer</h3>

<p>Каждый компьютер, подключенный к сети обладает неким IP-адресом.&nbsp; Для того, чтобы при обращении клиента к серверу не пришлось указывать ip-адрес, существует система доменных имен. При
    обращении клиента к доменному имени сначала идет обращение к DNS-серверу, получение ответа от него, содержащего IP-адрес целевого сервера, затем идет обращение по полученному IP-адресу.</p>

<p>Для формирования запросов к DNS-серверу есть несколько полезных утилит:</p>

<pre>
<code class="language-bash">nslookup [-q=ns|mx|afxr|txt] [name] [server]
          -q - тип запроса
          name - имя, которое хотим отрезолвить
          server - DNS-сервер, через который хотим отправить запрос, необязательный параметр,
по умолчанию будут использованы указанные в настройках клиентской машины сервера

Также можно использовать другие утилиты:

dig [@server] [name] [type]
host [name] [server]</code></pre>

<p>Для получения информации о других доменных именах, связанных с целевой системой (и включения их в поверхность атаки) можно получить список поддоменов данной доменной зоны. Такая задача называется
    zonetransfer. В большинстве случаев zonetransfer запрещают, но далеко не всегда.</p>

<p>Запрос может быть выполнен следующим образом (используется проект zonetransfer.me, созданный как раз для демонстрации этой возможности):</p>

<pre>
<code>nslookup -q=ns zonetransfer.me  - выдергиваем "авторитетные" dns-сервера для этой зоны

dig zonetransfer.me @dnsserver axfr  - в качестве dnsserver указываем сервер, полученный на первом шаге. </code></pre>

<p>Также можно использовать следующие команды под windows:</p>

<pre>
<code>В командной строке (cmd):

nslookup
set type=ns (указываем, чтохотим увидеть только записи типа ns - DNS-сервера, поддерживающие зону)
zonetransfer.me &lt;Enter&gt;  (получаем список DNS-серверов данной зоны)
server &lt;имя первого DNS-сервера&gt; (указываем, что теперь любые запросы программа отсылает ему)
ls -d zonetransfer.me (получаем вывод всего, что содержится в домене zonetransfer.me)
</code></pre>

<p>Как третий вариант - можно использовать веб-сервисы, например: http://www.digwebinterface.com/</p>

<h3>WhoIs</h3>

<p>Whois - предназначен для получения информации об определенном доменном имени.</p>

<p>Стандартная практика использования следующая:</p>

<pre>
<code>nslookup &lt;domain.com&gt; - резолвим домен, получая IP-адрес
whois &lt;ip из шага 1&gt; - получаем сеть, к которой принадлежит этот ip-адрес, выявленные адреса можно включать в поверхность атаки
</code></pre>

<p>Если выполнить:</p>

<pre>
<code>whois domain.com</code></pre>

<p>то мы получим данные из базы регистратора доменных имен. Для российских доменных имен информация о владельце доменных имен на данный момент не отображается, но для старых доменных имен вполне можно
    найти исторические данные в интернете. В зоне .com такого ограничения нет.</p>

<h3>Поисковые движки</h3>

<p>Содержат массу полезной информации. У поисковых движков есть свой язык запросов, который можно использовать.</p>

<pre>
<code>inurl: - позволяет задать паттерн, который должен встречаться в url
site: - позволяет искать все, относящееся к конкретному сайту
filetype: - позволяет определять типы документов по расширению (например можно искать все pdf на сайте)
cache: - в качестве параметр применяются url, поисковая машина вернет закешированную копию</code></pre>

<h3>Robots.txt</h3>

<p>Содержит информацию о каталогах, которые должны/не должны быть индексированы поисковыми системами.</p>

<p>Среди запрещенных для поисковой машины каталогов часто можно найти специфические для безопасности каталоги (содержащие, например, адрес интерфейса администратора).</p>

<h3>HTML-код</h3>

<p>Может содержать массу интересной информации. В целом стоит обращать внимание на следующие моменты:</p>

<ul>
    <li>комментарии - могут содержать массу интересной информации, например закомментированный код серверной части системы</li>
    <li>версии распространенных продуктов - позволяют понять &quot;на чем&quot; работает целевая система</li>
    <li>параметры - GET и POST-параметры, которые не используются по каким-либо причинам</li>
    <li>файлы и пути - расположение относительно корневой веб-директории</li>
</ul>

<h3>Сканирование портов</h3>

<p>Цель - понять что еще находится на целевом сервере, помимо интересущей нас системы.</p>

<p>Для сканирования портов используем стандартную утилиту nmap:</p>

<pre>
<code>nmap -sS -T4 -n &lt;target&gt;

 -sS      - посылать только syn и считать порт открытым если получен syn_ack
 -n       - не делать DNS-резолв, влияет на скорость работы
 -T4      - тайминг между запросами, от этого зависит скорость сканирования
 -vvv     - вывод информации о найденных портах по ходу сканирования а не после его окончания
 -p       - сканировать все 65000 портов, а не только самые популярные
 --reason - отображает причину, почему было принято решение о состоянии порта</code></pre>

<p>По <a href="https://www.shellhacks.com/ru/20-nmap-examples/">ссылке </a>также есть довольно много примеров использования команды с разным набором параметров.</p>

<h2><a id="ch2">Точки входа в систему</a></h2>

<p>Веб - приложение может принимать данные через:</p>

<ul>
    <li>GET / POST методы</li>
    <li>Cookies</li>
    <li>Headers</li>
    <li>Hosts</li>
    <li>Data sources</li>
</ul>

<p>Все эти входные данные могут быть модифицированы пользователем, при разработке это нужно всегда осознавать.</p>

<p>HTTP - протокол открытый, т.е. данные передаются без кодирования, любой запрос может быть без особых проблем воспроизведен вручную.&nbsp;</p>

<p>В ходе анализа как правило воспроизводится следующий цикл:</p>

<p><img alt="" class="rounded mx-auto d-block" src="/images/slide03.jpg" style="width: 60%;" /></p>

<p>Для каждого параметра можно проверить состояние системы в трех ситуациях: когда есть данные, когда нет данных и ошибочное состояние (например, параметр неверного типа).</p>

<h3>Интересные Header-ы</h3>

<p>HTTP 1.1 отличает от HTTP 1.0 наличие header-а &quot;Host&quot;. Это было введено для того, чтобы была возможность хостить несколько веб-серверов на одном физическом IP-адресе. Заголовок Host как и
    все остальные формируется клиентом.</p>

<p>Cookie - передаются в заголовку для сохранения состояния между сессиями.</p>

<p>Для того, чтобы определять IP-адрес пользователя, находящегося за прокси-сервером, был придуман служебный заголовок, который прокси-сервер дописывает:&nbsp;<a href="https://en.wikipedia.org/wiki/X-Forwarded-For">X-Forwarded-For</a>. Некоторые разработчики надеются таким образом распознать реальный адрес клиента и отдают значению этого заголовка
    приоритет в обработке. Делают тем самым хуже себе, т.к. заголовок легко подделывается.</p>

<h3>GET / POST запросы,&nbsp;их перехват и создание в&nbsp;консоли</h3>

<p>Для анализа (и подмены &quot;на лету&quot;) GET / POST запросов к серверу можно использовать т.н. перехватывающие прокси-сервера. Наиболее распространенные программы такого типа: <a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">OWASP ZAP</a>,&nbsp;&nbsp;<a href="https://portswigger.net/burp/﻿">Burp Suite</a>,&nbsp;<a href="http://www.telerik.com/fiddler﻿">Fiddler</a>.</p>

<p>Для выполнения запросов можно подсоединиться к целевому веб-серверу, например так:</p>

<pre>
<code>telnet ya.ru 80
GET / HTTP/1.1
Host: ya.ru</code></pre>

<p>Для организации HTTPS-соединения можно сделать так:</p>

<pre>
<code>openssl s_client -connect e.mail.ru:443
GET / HTTP/1.1
Host: e.mail.ru</code></pre>

<p>В качестве более-удобных инструментов для общения с веб-сервером из консоли можно использовать wget (<a href="http://help.ubuntu.ru/wiki/wget">русскоязычная справка</a>)&nbsp; и curl (<a href="http://osxh.ru/terminal/command/curl">русскоязычная справка</a>).</p>

<p>Версия curl для&nbsp;windows:&nbsp;<a href="http://curl.haxx.se/download.html" rel="nofollow">http://curl.haxx.se/download.html</a></p>

<p>Версия wget для&nbsp;windows:&nbsp;<a href="https://eternallybored.org/misc/wget/" rel="nofollow">https://eternallybored.org/misc/wget/</a></p>

<pre>
<code>wget -O - --header "headername:value" http://target.com
curl -H "headername:value" http://target.com</code></pre>

<p>Неожиданно, но, используя curl через GET-метод также можно передавать тело запроса (не средствами браузера). Например, так:</p>

<pre>
<code>curl -X GET -H "Content-Type: application/json" -d '{"the": "body"}' 'http://localhost/test/get.php'
</code></pre>

<p>Подробное обсуждение <a href="https://stackoverflow.com/questions/978061/http-get-with-request-body">здесь</a>.</p>

<p>Стоит помнить, что параметры в запросах часто передаются не в открытом виде, а , например закодированные в base64. В таком случае для их подмены нужно их расшифровать, подменить и зашифровать
    обратно по тому же алгоритму.</p>

<h2><a id="ch3">Уязвимости веб-приложений</a></h2>

<h3>Раскрытие служебных данных</h3>

<p>Раскрытие данных - это ошибка системы, позволяющая злоумышленнику получить информацию относительно логики работы атакуемой системы, её настроек, внутренней архитектуры, имеющихся пользователей,
    текущего состояния - всего того, что само по себе не является целью злоумышленника, однако может привести к взлому в совокупности с другой уязвимостью.</p>

<p>Возможные данные:</p>

<ul>
    <li>структура файловой системы</li>
    <li>пользователи</li>
    <li>исходный код</li>
    <li>внутренняя архитектура</li>
    <li>настройки</li>
</ul>

<p>Причины раскрытия данных:</p>

<ul>
    <li>ошибки приложения</li>
    <li>ошибки конфигурации</li>
    <li>системы контроля версий</li>
    <li>html-код</li>
    <li>&quot;мусорные&quot; файлы</li>
</ul>

<h3>Локальное включение файлов (LFI)</h3>

<p>Локальное включение данных довольно часто используется веб-системами , представляет собой передачу&nbsp;через параметры имен локально существующих файлов и их &nbsp;отображение пользователю.</p>

<p>Например, так:</p>

<pre>
<code>http://target.com/getpage.php?page=contacts.txt</code></pre>

<p>Код такого рода часто используется для навигации по страницам сайта.</p>

<p>Зная структуру каталогов веб-сервера можно &quot;попросить&quot; его отобразить содержимое других файлов, например, содержащих пароли (/etc/password), примерно так:</p>

<pre>
<code>http://target.com/getpage.php?page=../../../../../../etc/passwd</code></pre>

<p>Если кроме загрузки файла и отображения его содержимого происходит еще и их интерпретация, можно заставить сервер рекурсивно включать файл и посмотреть что из этого получится :)</p>

<pre>
<code>http://target.com/getpage.php?page=../getpage.php</code></pre>

<p>&nbsp;Если разработчик добавляет расширение к файлу, т.е. при вызове&nbsp;</p>

<pre>
<code>http://target.com/getpage.php?page=contacts</code></pre>

<p>в коде будет добавлено расширение и отображено содержимое файла contacts.txt, то можно использовать null-byte - символ, обозначающий конец строки, чтобы обрезать расширение.</p>

<pre>
<code>http://target.com/getpage.php?page=../../../../../../etc/passwd%00</code></pre>

<h3>Инъекция команд</h3>

<p>Инъекция команд - это уязвимость, позволяющая выполнить непредусмотренную разработчиком (или даже любую системную) команду на сервере. Может быть выполнена, если в системе делается вызов какой-либо
    команды на базе параметров, пришедших от пользователя.</p>

<p>Пример:</p>

<pre>
<code>http://hosttool.com/tools.php?host=1.2.3.4;pwd</code></pre>

<p>Точка с запятой в данном случае будет разделителем и выполнится команда вида:</p>

<pre>
<code>ping 1.2.3.4; pwd</code></pre>

<p>В результате мы увидим не только результат команды ping, но и текущий каталог в системе.</p>

<pre>
<code>http://hosttool.com/tools.php?host=1.2.3.4|pwd</code></pre>

<p>Используя вертикальную черту, можно передавать stdout одной команды на stdin следующей команды, организуя &quot;цепочку&quot;.</p>

<h3>SQL инъекция</h3>

<p>Представляет собой атаку, цель которой - модификация sql-запроса, выполняющегося на сервере базы данных. При успешном выполнении злоумышленник сможет выполнить на сервере команды.</p>

<p>Примером может быть запрос такого типа:</p>

<pre>
<code>http://target.com/login.php?user=alex' OR 1=1</code></pre>

<p>Основные подходы:</p>

<ul>
    <li>&nbsp;сворачивание условия WHERE к истиностному результату при любых значениях параметров (&#39; OR 1=1).</li>
    <li>присоединение к запросу результатов другого запроса (&#39; UNION select ...)</li>
    <li>закомментирование части запроса (&#39; --)</li>
</ul>

<h2><a id="ch4">Клиентские атаки</a></h2>

<p>В отличие от атак серверной части,&nbsp; для выполнения клиентских атак может быть нужно заставить пользователя совершить определенное действие, например, перейти по какой-то ссылке.</p>

<p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0">Same-origin
    policy</a> - это механизм для защиты данных и методов, пришедших из разных источников.</p>

<p>&quot;Одинаковость&quot; источника определяется по трем признакам: протокол, домен, порт.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px;">
    <tbody>
    <tr>
        <td>
            <p>Одинаковыми считаются:</p>

            <p>http://example.com/</p>

            <p>http://example.com/folder/</p>
        </td>
        <td>
            <p>Разными считаются:</p>

            <p>&nbsp;</p>

            <p>http://example.com/</p>

            <p>https://example.com/</p>

            <p>http://test.example.com/</p>

            <p>http://example.com:8080/</p>

            <p>http://otherexample.com/</p>
        </td>
    </tr>
    </tbody>
</table>

<p>Задача клиентских атак как раз сводится к тому, чтобы каким-либо образом обойти <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0">Same-origin
    policy</a>.</p>

<h3>CSRF (cross-site request forgery)</h3>

<p>Основывается на идее, что страницы могут включать в себя данные из разных источников.</p>

<p>На контролируемом злоумышленником домене размещается ссылка, осуществляющая переход на сторонний сайт. При этом пользователь сайта-злоумышленника может быть авторизован на этом стороннем сайте.</p>

<p>Например, включив в код сайта-злоумышленника&nbsp;следующую строку, в случае, если пользователь авторизован на target.com, он может сам того не зная оставлять комментарии со спамом:</p>

<pre>
<code>&lt;img src="http://target.com/post_comment.php?text="spam"/&gt;</code></pre>

<p>&nbsp;Переделка GET запроса на POST-запрос на target.com не поможет, тогда злоумышленник добавит код вида:</p>

<pre>
<code>&lt;form action ='http://target.com/form.php'&gt;
&lt;input type=hidden name='id' value=1&gt;
&lt;/form&gt;
&lt;script&gt;submitForm()&lt;/script&gt;</code></pre>

<p>Для защиты следует использовать CSRF-токены - механизм &quot;подписывания&quot; форм по алгоритму, неизвестному злоумышленнику .При создании защиты от csrf распространенная ошибка - генерация
    предсказуемых security-токенов. Токены должны всегда создаваться на основе недоступной злоумышленнику информации (зашифровать имя пользователя в md5 - плохая идея!).</p>

<h3>XSS (cross-site scripting)</h3>

<p>Одна из наиболее часто используемых атак веб-приложений. Основывается на факте, что злоумышленник может вставлять свой код в ответ от веб-сервера пользователю. Основная задача атаки - обойти <a href="http://www.w3.org/Security/wiki/Same_Origin_Policy">Same Origin Policy</a> и получить доступ к данным и функционалу клиентской части веб-приложения в рамках пользовательской сессии и с
    правами ее пользователя.</p>

<p>Существует несколько основных подходов к осуществлению XSS - атак.</p>

<p><strong>Reflected XSS -з</strong>лоумышленник создает ссылку, которая использует найденную уязвимость, передает ее пользователю. Пользователь переходит на целевой веб-сервер и получает ответ,
    подконтрольный злоумышленнику. Таким образом браузер пользователя можно заставить выполнять какие-либо действия.&nbsp;</p>

<p>Выполняемый код может быть в составе ссылки, отправленной пользователю:</p>

<pre>
<code>www.target.com/script.php?lang=en&lt;script&gt;alert(1)&lt;/script&gt;</code></pre>

<p>Чтобы пользователю не был виден активный элемент - ссылка может быть закодирована механизмом кодирования узлов (goo.gl и т.п.), шифровка параметров в base64 и т.п. Такие ссылки уже вызовут меньше
    подозрений у пользователя.</p>

<p><strong>Stored XSS -</strong> способ реализации атаки, когда код размещается на ресурсе (например, пост с неотфильтрованным js-кодом в гостевой книге), после чего каждый пользователь, зашедший на
    страницу невольно выполняет этот код.</p>

<p><strong>DOM-based XSS </strong>- не требует никаких обращений на сервер со стороны пользователя. Все предпосылки для создания XSS находится в самом браузере. Основывается на том, что в контексте
    самого браузера есть код, обрабатывающий параметры и содержащий ошибку. К примеру, если участок JS- кода имеет доступ к параметру url и на его основе формирует некий html-код на странице.</p>

<p>Стоит проверить наличие в коде страницы таких конструкций, как:</p>

<pre>
<code>document.write()
document.writeln()
eval()
.innerHTML
</code></pre>

<p>Еще один важный момент - если на странице есть flash (.swf),&nbsp; то все, что приходит от swf также подлежит строгой валидации, о чем часто забывают</p>

<p>Основной способ защиты - <strong>правильная обработка всех входных и выходных данных</strong>. Множество векторов атаки описано здесь:&nbsp;<a href="http://html5sec.org/">http://html5sec.org/</a>,
    стоит об этом помнить. Много полезного про XSS и то, как правильно строить защиту от него также описано в <a href="https://habrahabr.ru/company/pt/blog/149152/">годной статье на хабре</a>.</p>

<h3>Инъекция заголовков (header injection)</h3>

<p>В рамках HTTP-протокола заголовки разделяются друг от друга символом перевода каретки (%0d%0a). Если на сайте есть метод, позволяющий сгенерировать заголовок, содержащий символ перевода каретки,
    после этих символов можно поставить новый header.</p>

<p>Например, если есть некая страница: http://target.com?jump=&lt;user input&gt; при переходе на нее, генерирующая в ответе заголовок</p>

<pre>
<code>...
Location: &lt;user input&gt;</code></pre>

<p>то передав запрос вида:<br />
    http://target.com?jump=hell%0d%0aSet-Cookie: gotohell%3d1 получим в ответе:</p>

<pre>
<code>...
Location: hell
Set-Cookie: gotohell = 1
...</code></pre>

<p>Таким образом можно будет внедряя заголовки / куки осуществлять XSS-атаку в любом месте страницы.</p>

<h3>Фиксация сессии (Session Fixation)</h3>

<p>На данный момент эта уязвимость встречается достаточно редко. Эта уязвимость связана не с ошибками фильтрации данных, а носит архитектурный характер. Реализуется таким образом: есть сервер, который
    раздает полномочия на базе сессий. При первом заходе, когда пользователь еще не залогинился - ему уже выдается некая сессия. После того, как он вводит корректные логин и пароль, идентификатор
    сессии остается прежним, а сервер запоминает, что эта сессия теперь относится к этому пользователю.</p>

<p>Злоумышленник в таком сценарии создает сессию (просто зайдя на сайт и получив sessionid). Далее он передает в рамках какого-то запроса передает сессионный идентификатор пользователю. Пользователь
    заходит по этой ссылке, вводит свой логин и пароль, сессия при этом остается той же самой. Теперь злоумышленник, используя тот же sessionid имеет права доступа, как у пользователя.</p>

<p>На практике сессии обычно хранятся в cookies-переменных. Таким образом злоумышленнику надо найти&nbsp; уязвимость, которая позволит пользователю добавить некое cookies-значение, например описанную
    выше header injection. Как вариант можно попробовать передать значение сессии через GET / POST параметр в надежде, что код на стороне сервера не анализирует источник, а работает с неким глобальным
    массивом, содержащим GET, POST, COOKIE параметры.</p>

<h2><a id="ch5">Пост-эксплуатация</a></h2>

<p>Пост-эксплуатация - это то, что можно сделать с целевой системой после того, как удалось найти уязвимость и выполнить какой-то участок кода на целевой системе.</p>

<p>Основные паттерны, по которым работают злоумышленники предполагают:</p>

<ul>
    <li>получить доступ на выполнение (желательно в реальном времени)</li>
    <li>изучение данных, хранящихся на сервере</li>
    <li>перехват данных, которых нет на системе сейчас, но они могут появиться в будущем</li>
    <li>организация перманентного доступа к целевой системе</li>
</ul>

<p>Злоумышленник может получать информацию о скомпрометированной системе, анализируя:</p>

<ul>
    <li>конфигурацию системы (логин и пароль к БД в исходных кодах)</li>
    <li>конфигурацию веб-сервера (например httpd.conf, .htaccess)</li>
    <li>исходные коды приложения (ищем уязвимости, анализируя логику приложения)</li>
    <li>доступы к окружению (находясь внутри сети может быть проще попасть на соседние сервера)</li>
    <li>базы данных (и аутентификационная информация,к другим системам, хранящаяся в них)</li>
</ul>

<h3>Получение паролей из хеша</h3>

<p>Чаще всего пароли хранят в виде хешей. Но есть способы получить пароль, имея его хеш.</p>

<p>Один из самых известных онлайн-брутфорсеров паролей: John the Ripper.</p>

<p>Может быть использован, например, так:</p>

<pre>
<code>john &lt;passwd file&gt;
john --wordlist=&lt;dictionary pass&gt; &lt;passwd file&gt;
john --format=&lt;formatname&gt; passfile    (список форматов: john --list=formats)
</code></pre>

<h3>Организация перманентного доступа</h3>

<p>Самый простой способ - создать своего пользователя (желательно замаскировав его под системного).</p>

<p>Другой вариант - бинарные бекдоры, которые кладутся на систему и организуется их периодическое выпролнение (через cron или при каждом вызове любой частой команды, например ls).</p>

<p>Если удалось получить доступ под пользователем веб-сервера, можно сделать веб-бекдор, например положив куда-либо на вебсервере скрипт, позволяющий выполнять произвольные действия.</p>

<p>Самый жесткий вариант - патч ядра операционной системы, включение бекдора туда.</p>

<h2><a id="ch6">Полезные ссылки</a></h2>

<p><a href="http://projects.webappsec.org/w/page/13246978/Threat%20Classification">Классификация угроз от Web App Security Consorcium</a></p>

<p><a href="http://html5sec.org/">Cheatsheet по угрозам безопасности HTML и не только</a></p>

<p><a href="https://www.ptsecurity.com/upload/corporate/ru-ru/analytics/PT-devteev-Advanced-SQL-Injection.pdf">SQL Injeciton от А до Я в pdf от Positive Technologies</a></p>

<p><a href="https://www.exploit-db.com/">База раскрытых уязвимостей Exploit DB</a></p>

<p><a href="https://vulners.com/">Поисковик по уязвимостям vulners.com</a> ( и еще есть <a href="https://habrahabr.ru/company/xakep/blog/305262/">статья о нем на хабре</a>)</p>

<p><a href="https://www.youtube.com/playlist?list=PLrCZzMib1e9qiiSWgZ6pI5HiQzFc4hhdo">Лекции от того же автора на YouTube </a>(во многом похожи, но есть часть тем, не раскрытых в курсе, например
    раздел про CMS)</p>

<p><a href="https://habrahabr.ru/post/325298/">Обзор инструментов для вскрытия хеша (статья на хабре)</a></p>


    </article>
    <section class="post-nav" style="margin-bottom: 60px;">
        <div id="left-page">
            <div id="left-link">
                <div id="left-arrow"><i class="fa fa-chevron-circle-left"></i></div>
                <a href="../posts/redhat7-centos-7-poleznye-komandy"> RedHat7 / CentOS 7: полезные команды</a>
            </div>
        </div>
        <div id="right-page">
            <div id="right-link">
                <a href="../posts/shpargalka-po-sqlplus">Шпаргалка по SQL*Plus </a>
                <div id="right-arrow"><i class="fa fa-chevron-circle-right"></i></div>
            </div>
        </div>
    </section>
    <div>
    </div>
</main>
    <footer>
        <h6>
            Copyright &copy 2017-2020
- ezhvsalate        </h6>
    </footer>
</div>
</body>
</html>
