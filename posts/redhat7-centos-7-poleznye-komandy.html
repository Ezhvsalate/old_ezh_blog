<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Записная книжка ежа - RedHat7 / CentOS 7: полезные команды</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css"/>
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link href="https://fonts.googleapis.com/css?family=Exo+2" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="../theme/css/main.css"/>
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/zenburn.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

<meta name="tags" content="ansible" />
</head>
<body>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }

    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style><div id="container">
    <header>
        <h1 style="margin-bottom: 0"><a href="../"><img src="../theme/images/logo3.svg" style="width: 120px; box-shadow: None;" alt="logo"/> Записная книжка ежа</a></h1>
        <ul class="social-media">
            <li><a href="https://github.com/Ezhvsalate"><i class="fa fa-github fa-lg" aria-hidden="true"></i></a></li>
        </ul>
        <!--        <p style="margin-top: 0; margin-left: 120px;"><em>Еж иголки спрятатать не может</em></p>-->
    </header>
    <nav>
        <ul>
            <li><a                    class="active" href="../category/posty.html"> Посты </a></li>
            <li><a href="../about/">О блоге</a>
            </li>
        </ul>
    </nav>
<main>
    <article>
        <h2>RedHat7 / CentOS 7: полезные команды</h2>
        
        <aside>
            <ul>
                <li>
                    Опубликовано: <time datetime="2018-06-01 09:44:39+03:00">01 июн 2018</time>
                </li>
                <li>Время прочтения: 6 мин</li>
                <li>
                    Tags:
                    <a href="../tag/ansible.html"><em>#ansible</em></a>
                </li>
            </ul>
        </aside>
        
<p>А у нас на работе случилось тестирование по знанию команд linux :)</p>

<p>На самом деле это круто,&nbsp;когда работа мотивирует изучать что-то новое и постоянно развиваться. Тем более, ребята подготовили неплохие конспекты и даже тем, кто с терминалом был &quot;на вы&quot;
    при минимальных&nbsp; усилиях разобраться в происходящем оказалось не очень сложно.</p>

<p>Глядя на эти конспекты, мне стало немного грустно - работа имеет свойство меняться, а терять такую крутую подборку не хотелось бы. Да и формат меня местами не устраивал. В итоге было решено
    переработать материал в такую простыню-шпаргалку, частично используя материалы для подготовки к тестированию, частично - расширяя своими заметками.</p>

<p>В этом посте осуществлена попытка собрать необходимый минимум полезных команд, часто используемых при решении типовых задач в ОС Linux, в частности - дистрибутивов Red Hat Enterprise Linux / Cent
    OS 7.</p>

<h2 id="id-ОрганизацияфайловойсистемыLinuxиосновныекаталоги-СтруктуракаталоговLinux"><a id="ch1">Структура каталогов</a></h2>

<p>Основные каталоги и структура файловой системы Linux регламентируются FHS - <a href="https://ru.wikipedia.org/wiki/FHS" rel="nofollow">Filesystem Hierarchy Standard</a>. FHS поддерживается Free
    Standards Group &mdash; некоммерческой организацией, в составе которой находятся крупные разработчики программного и аппаратного обеспечения, такие как HP, Red Hat, IBM и Dell.</p>

<pre>
<code>Структура каталогов Linux
/ — корень
----/bin — (binaries) бинарные файлы пользователей
----/boot — файлы загрузчика
----/dev — (devices) файлы устройств
----/etc — (etcetera) конфигурационные файлы
----/home — домашние директории пользователей
----/lib (library) — системные библиотеки
----/media — съёмные носители
----/mnt (mount) — точки монтирования
----/opt (optional applications) — дополнительные приложения
----/proc — (process) информация о процессах
----/root - домашний каталог суперпользователя (root)
----/run — процессы
----/sbin — (system binaries) системные исполняемые файлы
----/srv (server) — сервер
----/sys (system) — информация о системе
----/tmp (temp) — временные файлы
----/usr — (user applications) программы пользователя
--------/usr/bin — исполняемые файлы
--------/usr/sbin — системные исполняемые файлы
--------/usr/lib— библиотеки
--------/usr/local — пользовательские программы, библиотеки и настройки
----/var (variable) — переменные файлы
--------/var/log — файлы логов
--------/var/lib — базы данных
--------/var/lock — файлы блокировок
--------/var/run — PID процессов</code></pre>

<h3>/ - корень</h3>

<p>Главный каталог, по сути - файловая система Linux. Только root может менять и читать файлы в этом каталоге.</p>

<h3>/bin (binaries) - бинарные файлы пользователей</h3>

<p>Содержит исполняемые файлы, которые можно использовать когда не подключен каталог /usr. В основном - общие команды, например cat / ls / ps и др.</p>

<h3>/boot &mdash; файлы загрузчика</h3>

<p>Cодержит ядро и другие файлы, используемые при загрузке системы.</p>

<h3>/dev (devices) - файлы устройств</h3>

<p>В Linux все устройства являются файлами в каталоге /dev. Инициализируется при запуске системы - сканируются подключенные устройства и для них создаются специальные файлы.</p>

<h4>/dev/null - псевдоустройство, в которое можно записать все что угодно и оно исчезнет навсегда.</h4>

<p>Используя его, можно, например подавить вывод на stdout:</p>

<pre>
<code class="language-bash">$ cat $filename &gt;/dev/null</code></pre>

<h4>/dev/shm - раздел файловой системы, размещенный в оперативной памяти</h4>

<p>Может быть использован для увеличения производительности приложений. При перезагрузке информация в разделе стирается.</p>

<h3>/etc (etcetera) - конфигурационные файлы</h3>

<p>Здесь хранятся конфигурационные файлы всех установленных в системе программ, скрипты запуска и завершения системных демонов, монтирования файловых систем и авторазгрузки программ.</p>

<h3>/home &mdash; домашние директории пользователей</h3>

<p>В этой папке хранятся домашние каталоги всех пользователей. В них они могут хранить свои личные файлы, настройки программ и т д.</p>

<h3>/lib (library) &mdash; системные библиотеки</h3>

<p>Содержит файлы системных библиотек, которые используются исполняемыми файлами в каталогах /bin и /sbin.</p>

<p>Библиотеки имеют имена файлов с расширением *.so и начинаются с префикса lib*. Например, libncurses.so.5.7. Папка /lib64 в 64 битных системах содержит 64 битные версии библиотек из /lib.</p>

<h3>/media &mdash; съёмные носители</h3>

<p>В этот каталог система монтирует все подключаемые внешние накопители &mdash; флешки, оптические диски и другие носители информации.</p>

<h3>/mnt (mount) &mdash; точки монтирования</h3>

<p>В этот каталог могут быть смонтированы внешние или дополнительные файловые системы.</p>

<h3>/opt (optional applications) &mdash; дополнительные приложения</h3>

<p>В эту папку устанавливаются проприетарные программы, игры или драйверы.</p>

<h3>/proc (process) &mdash; информация о процессах</h3>

<p>Содержит информацию о запущенных процессах, обновляемую в реальном времени. Также там есть информация об использовании системных ресурсов (/proc/cpuinfo, /proc/meminfo, /proc/uptime).</p>

<h3>/run &mdash; процессы</h3>

<p>Еще один каталог, содержащий PID файлы процессов, похожий на /var/run, но в отличие от него, он размещен в TMPFS, а поэтому после перезагрузки все файлы теряются.</p>

<h3>/sbin (system binaries) - системные исполняемые файлы</h3>

<p>Также как /bin содержит исполняемые файлы, доступные на ранних этапах загрузки, но здесь - программы, выполняемые только с правами суперпользователя - системные утилиты.</p>

<h3 id="id-ОрганизацияфайловойсистемыLinuxиосновныекаталоги-/srv(server)—сервер">/srv (server) &mdash; сервер</h3>

<p>В этом каталоге содержатся файлы серверов и сервисов. Например, могут содержаться файлы веб-сервера apache.</p>

<h3>/sys (system) &mdash; информация о системе</h3>

<p>Назначение каталогов Linux из этой папки &mdash; получение информации о системе непосредственно от ядра. Это еще одна файловая система, организуемая ядром и позволяющая просматривать и изменить
    многие параметры работы системы, например, работу swap, контролировать кулеры и многое другое.</p>

<h3>/tmp (temp) &mdash; временные файлы</h3>

<p>В этом каталоге содержатся временные файлы, созданные системой, любыми программами или пользователями. Все пользователи имеют право записи в эту директорию.Файлы удаляются при каждой
    перезагрузке.</p>

<h3>/usr &mdash; (user applications) программы пользователя</h3>

<h4>/usr/bin &mdash; исполняемые файлы</h4>

<p>Содержит исполняемые файлы различных программ, которые не нужны на первых этапах загрузки системы, например, музыкальные плееры, графические редакторы, браузеры и так далее.</p>

<h4>/usr/lib&mdash; библиотеки</h4>

<p>Содержит библиотеки для программ из /usr/bin или /usr/sbin.</p>

<h4>/usr/local &mdash; пользовательские программы, библиотеки и настройки</h4>

<p>Содержит файлы программ, библиотек, и настроек созданные пользователем. Например, здесь могут храниться программы собранные и установленные из исходников и скрипты, написанные вручную.</p>

<h4>/usr/sbin &mdash; системные исполняемые файлы</h4>

<p>Содержит двоичные файлы программ для системного администрирования, которые нужно выполнять с правами суперпользователя. Например, таких как Gparted, sshd, useradd, userdel и т д.</p>

<h3>/var (variable) &mdash; изменяемые файлы</h3>

<p>Содержит постоянно изменяемые файлы, генерируемые процессами во время работы. Здесь есть системные журналы, кеши, базы данных и т.п.</p>

<h4>/var/log - файлы логов</h4>

<p>Содержит большинство логов всех установленных в операционной системе программ.</p>

<h4>/var/lib &mdash; базы данных</h4>

<p>Содержит файлы баз данных, пакеты и т.п.</p>

<h4>/var/lock - блокировки</h4>

<p>Файлы, расположенные здесь, означают, что ресурс, файл или устройство занято и не может быть использовано другим процессом.</p>

<h4>/var/run &mdash; PID процессов</h4>

<p>Содержит идентификаторы процессов, которые могут использоваться для взаимодейстия между программами. В отличие от /run данные сохраняются после перезагрузки.</p>

<h2><a id="ch2">Пользователи и группы</a></h2>

<p>ОС UNIX предлагает базовые средства защиты и совместного использования файлов на основе отслеживания пользователя и группы, владеющих файлом, трех <em>уровней доступа</em> (для
    пользователя-владельца, для пользователей группы-владельца, и для всех остальных пользователей) и трех базовых <em>прав доступа</em> к файлам (на <em>чтение</em>, на <em>запись</em> и на <em>выполнение</em>).
    Базовые средства защиты процессов основаны на отслеживании принадлежности процессов пользователям.</p>

<p>Для отслеживания владельцев процессов и файлов используются числовые идентификаторы. <em>Идентификатор пользователя</em> и <em>группы</em> - целое число (обычно) в диапазоне от 0 до 65535.
    Присвоение уникального идентификатора пользователя выполняется при заведении системным администратором нового регистрационного имени. Среди пользователей системы выделяется один пользователь -
    <strong><em>системный администратор</em> </strong>или<strong> <em>суперпользователь</em></strong>, обладающий всей полнотой прав на использование и конфигурирование системы. Это пользователь с
    идентификатором 0 и регистрационным именем <strong>root</strong>.</p>

<p>Учетные записи пользователей, как и большинство другой информации о конфигурации системы UNIX, по традиции, представлена в виде текстовых файлов: /etc/passwd, /etc/group и /etc/shadow (в системах с
    теневым хранением паролей).</p>

<p>Основные команды для работы с пользователями и группами (часть команд указанных ниже будет требовать sudo для выполнения):</p>

<pre>
<code class="language-bash">$ useradd username            - добавить пользователя username
$ useradd -D                  - показать доступные при добавлении пользователя настройки
$ passwd                      - изменить пароль пользователю (далее следовать подсказкам системы)
$ userdel                     - утилита удаления пользователя

$ groupadd group1             - добавить группу group1
$ usermod -aG group1 user1    - добавить пользователя user1 в группу group1
$ groupmod -n group2 group1   - изменить имя группы group1 на group2
$ groupdel                    - утилита удаления группы

$ su user1                    - сменить текущего пользователя на user1 (если не указать пользователя именем по умолчанию будет root)
$ sudo somecommand            - выполнить команду somecommand от лица пользователя root</code></pre>

<p>В современных дистрибутивах Linux вместо root аккаунта для администрирования как правило используется утилита sudo (substitute user and do), позволяющая выполнить команду от лица пользователя
    root.</p>

<p>Все настройки sudo находятся в файле <strong>/etc/sudoers</strong>. Здесь можно настроить очень много параметров, начиная от кому будет позволено выполнять команды от имени суперпользователя и
    заканчивая ограничением набора доступных команд. Неправильный синтаксис, добавленный в этот файл, может полностью нарушить распределение прав между пользователями. Потому для работы с этим файлом
    используется утилита <strong>visudo,</strong> которая открывает файл в обычном текстовом редакторе, но во время сохранения файла <strong>проверяет его синтаксис</strong>. Это позволяет избежать
    ошибок в конфигурации.<strong> </strong></p>

<h2><a id="ch3">Работа с файловой системой: навигация, создание-перемещение-удаление файлов, ссылки</a></h2>

<p>Основные команды, используемые для навигации по файловой системе из окна терминала, создание, перемещение и удаление файлов и каталогов:</p>

<pre>
<code>$ cd           - перейти в домашнюю директорию
$ cd  ~        - перейти в домашнюю директорию
$ cd  /        - перейти в корневую директорию
$ cd  -        - перейти в директорию, где находились до этого
$ cd ..        - перейти на уровень выше
$ pwd          - вывести текущую рабочую директорию (где находитесь)
$ ./myprog     - запуск исполняемого файла myprog, находящегося в текущей директории


$ ls                 - вывести список директорий и файлов в текущей рабочей директории
$ ls -a              - включить в вывод скрытые файлы (их имена начинаются с точки)
$ ls -l              - добавить к выводу более подробную информацию
$ mkdir d1 d2        - создать директории d1 и d2 в текущей рабочей директории
$ mkdir -p d1/d2     - создать вложенные директории
$ touch f.txt        - создать файл f.txt
$ echo "123" &gt; f.txt - записать "123" в файл f.txt (если файла нет - будет создан, если есть - перезаписан)
$ cat f.txt          - вывод содержимого файла f.txt
$ cp f.txt f2.txt    - скопировать файл f.txt в f2.txt
$ mv f.txt f2.txt    - переместить файл f.txt в f2.txt
$ cp -vr dir1/ dir2  - скопировать рекурсивно (ключ r) содержимое директории dir1 в dir2 и вывести информацию о выполненной работе (ключ v)
$ mv -v /opt ~/1.txt ~/2.txt - переместить из домашней директории в /opt файлы 1.txt и 2.txt и вывести информацию о выполненной работе (ключ v)
$ rm f.txt f2.txt     - удалить f.txt и f2.txt
$ rm -rf mydir        - удалить директорию mydir со всем содержимым (ключ r) игнорируя несуществующие файлы и аргументы (ключ f, force)</code></pre>

<p>В ОС Linux существует два вида ссылок.</p>

<p><strong>Жесткие ссылки </strong>привязываются к иноду, таким образом, файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его инодом связано хотя бы одно
    имя. Понятия &laquo;жёсткая ссылка на файл&raquo; и &laquo;имя файла&raquo; являются синонимами.</p>

<pre>
<code class="language-bash">$ touch firstlink             - создали файл
$ ln firstlink secondlink     - создали жесткую ссылку на него
$ ls -i firstlink secondlink  - вывели содержимое рабочего каталога с инодами: они равны

15782 firstlink 15782 secondlink</code></pre>

<p>Жесткие ссылки могут быть только на файлы, не на директории. Также нельзя создать жесткую ссылку на файл в другой файловой системе (у каждой ФС свой набор инодов).</p>

<p><strong>Cимволические ссылки </strong>(или <strong>симлинки</strong>) - специальный вид файла, который ссылается на другой файл по имени, а не напрямую на инод. Симлинки не предохраняют файл от
    удаления. Если файл удалить, то симлинк на него станет нерабочим (или битым).</p>

<p>Симлинки создаются командой ln с опцией &#39;-s&#39;:</p>

<pre>
<code>ln -sv  ./versions/20180702-163849/ ./current    - создать симлинк current на директорию ./versions/20180702-163849/
</code></pre>

<p>При работе с большим количеством файлов бывает удобно использовать маски - т.н. wildcards.</p>

<p>Wildcard &quot;*&quot; соответствует нулю или большему количеству символов:</p>

<pre>
<code>$ ls -d /etc/g* - вывести список файлов в директории /etc имена которых начинаются с "g" и файл с именем "g" (если такой существует)
$ rm file*      - удалить все файлы, имена которых начинаются в file</code></pre>

<p>Wildcard &quot;?&quot; заменяет один любой символ:</p>

<pre>
<code>$ rm myfile?      - удалить все файлы, с именами начинающимися со слова "myfile" за которым следует один любой символ</code></pre>

<p>Шаблон &quot;[]&quot; позволяет явно указать набор символов - будут найдеты совпадения, содержащие один из указанных в скобках символов. Также в можно указать диапазон символов (для этого
    используется символ &ndash;/дефис) или несколько диапазонов подряд, тогда шаблон будет совпадать с одним любым символом из этого диапазона:</p>

<pre>
<code>$ myfile[12]         — соответствует myfile1 и myfile2
$ [Cc]hange[Ll]og    — соответствует файлам с именами Changelog, ChangeLog, changeLog, и changelog
$ ls /etc/[0-9]*     — вывести список файлов в директории /etc/ имена которых начинаются с цифры
$ ls /tmp/[A-Za-z]*  — вывести список файлов в директории /tmp/ имена которых начинаются с латинской буквы (заглавной или прописной)</code></pre>

<h2><a id="ch4">Управление процессами и потоками, отправка сигналов, kill</a></h2>

<p><strong>Процесс (process)</strong> &mdash; некая виртуальная среда, инкапсулирующая в себе ресурсы (открытые файлы, файлы отображенные в память...) и их дескрипторы, потоки и т.д. Каждый процесс
    имеет как минимум один поток. Также каждый процесс имеет свое собственное виртуальное адресное пространство и контекст выполнения, а потоки одного процесса разделяют адресное пространство
    процесса. Некоторые приложения могут создавать несколько процессов одновременно.</p>

<p>Каждому процессу в системе назначаются числовые идентификаторы <strong>PID </strong>(<strong>Process Identifier</strong>) в диапазоне от 1 до 65535 и идентификаторы родительского процесса <strong>PPID
    (Parent Process Identifier</strong>).</p>

<pre>
<code class="language-bash">$ ping ya.ru &gt; /dev/null &amp;   - оператор &amp; означает запуск процесса в фоновом режиме (не блокирует терминал)
$ jobs                       - просмотреть запущенные в фоновом режиме задачи
$ fg [job id]                - вернуть в терминал задачу с определенным идентификатором
ctrl-Z, затем
$ bg           - приостановить выполнение задачи и продолжить ее в фоновом режиме
$ ps aux                     - просмотр информации о запущенных процессах всех пользователей
$ top                        - непрерывно отобразить информацию самых активных процессов
$ htop                       - более продвинутая версия top, устанавливается отдельно. Показывает все процессы в системе, использование процессоров и памяти</code></pre>

<p>Сигнал в операционных системах семейства Unix - асинхронное уведомление процесса о каком-либо событии.</p>

<p>Когда сигнал послан процессу, операционная система прерывает выполнение процесса, при этом, если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик,
    передав ему информацию о сигнале, если процесс не установил обработчик, то выполняется обработчик по умолчанию.</p>

<pre>
<code class="language-bash">$ kill -l                    - все доступные в системе сигналы
$ kill [ -s сигнал ] pid     - отправить процессу pid сигнал</code></pre>

<p>По умолчанию отправляется сигнал <strong>SIGTERM</strong>. Для безусловного завершения процесса можно отправить <strong>SIGKILL</strong>. Т.к. в большинстве систем SIGKILL имеет идентификатор 9,
    часто встречается команда в сокращенной форме записи:</p>

<pre>
<code class="language-bash">$ kill -9 123     - безусловно, "жестко" завершить процесс 123</code></pre>

<h2><a id="ch5">SSH и передача файлов</a></h2>

<p><strong>SSH</strong> (<strong>S</strong>ecure <strong>Sh</strong>ell) &mdash; защищенный протокол для удаленного доступа к компьютерам. В *nix-подобных системах (Linux, macOS) ssh-клиент обычно
    установлен по умолчанию и подключаться можно напрямую из терминала. Для подключения нужно указать адрес сервера и, опционально, имя пользователя и порт.</p>

<p>Простейший вариант - подключение по паролю. В таком случае система будет запрашивать пароль каждый раз при подключении.</p>

<p>Для подключения без ввода пароля можно использовать ключи: приватный (закрытый) и публичный (открытый). Эти ключи связаны друг с другом таким образом, что зашифровав информацию одним ключом,
    расшифровать ее можно только другим.</p>

<p>Для создания ключей необходимо выполнить команду:</p>

<pre>
<code class="language-bash">$ ssh-keygen</code></pre>

<p>Опционально можно ввести passphrase.</p>

<p>Будут созданы два файла:</p>

<p>~/.ssh/id_rsa &mdash; приватный ключ.Его нельзя никому передавать.</p>

<p>~/.ssh/id_rsa.pub &mdash; публичный ключ. Можно спокойно распространять.</p>

<p>Для загрузки публичного ключа на сервер нужно выполнить на локальной машине команду:</p>

<pre>
<code class="language-bash">$ ssh-copy-id -i /home/demo/.ssh/id_rsa.pub user@remote_host</code></pre>

<p>Другой вариант - добавить на удаленной машине в файл ~/.ssh/authorized_keys содержимое публичного ключа.</p>

<p>Для более удобной работы с ключами можно добавить ключ к ssh-агенту. После этого для него больше не будет спрашиваться passphrase (если был задан) и не нужно будет вводить ключ вручную &mdash; он
    будет автоматически использован при соответствующем подключении.</p>

<pre>
<code class="language-bash">$ ssh-add /home/demo/.ssh/id_rsa   -  добавить ключ в запущенный в системе агент (попросит passphrase, если задан).</code></pre>

<p>ssh-agent привязан к сессии. Поэтому, например, если перезагрузить компьютер, то ключи нужно будет добавлять в агент заново.</p>

<p>Протокол SSH можно использовать для передачи файлов на удалённый сервер и загрузки их оттуда.</p>

<pre>
<code>$ scp root@hostmane:/home/user/file.tar.gz /opt - скачать с сервера файл /home/user/file.tar.gz в /opt
$ scp /opt/file.tar.gz root@hostmane:/home/user - загрузить на удаленный сервер в /home/user файл /opt/file.tar.gz
</code></pre>

<h2><a href="https://confluence.billing.ru/pages/viewpage.action?pageId=126960236" id="ch6">Перенаправление ввода/вывода</a></h2>

<p>Процесс взаимодействия с пользователем выполняется в терминах записи и чтения в файл. Вывод на экран представляется как запись в файл, а ввод &mdash; как чтение файла. Файл, из которого
    осуществляется чтение, называется <em>стандартным потоком ввода</em>, а в который осуществляется запись &mdash; <em>стандартным потоком вывода</em>. Существует еще и <em>стандартный поток
        ошибок</em>, на который выводятся все сообщения об ошибках и те информативные сообщения о ходе работы программы, которые не могут быть выведены в стандартный поток вывода.</p>

<pre>
<code class="language-bash">$ ls -l &gt; file.txt  - вывести содержимое директории в файл
$ wc -w &lt; file.txt  - посчитать количество слов в файле
</code></pre>

<p>Можно организовать конвейер (pipe) выполняемых команд.</p>

<pre>
<code class="language-bash">$ cat myfile | grep Linux | wc -l</code></pre>

<p>В примере выше вывод команды <strong>cat</strong>, т. е. текст из файла myfile, будет направлен на вход команды <strong>grep</strong>, которая выделит только строки, содержащие слово &quot;Linux&quot;.
    Вывод команды <strong>grep</strong> будет, в свою очередь, направлен на вход команды <strong>wc -l</strong>, которая подсчитает число таких строк. Статус выхода из канала совпадает со статусом
    выхода, возвращаемым последней командой.</p>

<h2><a href="https://confluence.billing.ru/pages/viewpage.action?pageId=126468683">Работа с текстовыми файлами</a><a id="ch7">, find и grep</a></h2>

<p><strong>l</strong><strong>ess - </strong>программа для просмотра содержимого текстовых файлов с возможностью его прокрутки. Умеет искать текст по шаблону и подсвечивать результат. Быстро работает с
    файлами больших размеров, т.к. не нуждается в чтении всего файла перед стартом.</p>

<pre>
<code class="language-bash">$ less myfile     - просмотреть содержимое файла</code></pre>

<p>После открытия текстового файла внутри утилиты можно набирать разные команды (они отображаются в левом нижнем углу), рассмотрим некоторые из них.</p>

<p>Для вызова справки внутри утилиты воспользуйтесь клавишей<strong> h</strong>.</p>

<p>Поиск внутри утилиты:</p>

<pre>
<code>/text    - поиск слова text "вперёд", начиная с первой отображаемой строки
?text    - поиск слова text "назад", начиная с последней отображаемой строки</code></pre>

<p>В режиме поиска:</p>

<pre>
<code>n            - следующее совпадение
N (shift-n)  - предыдущее совпадение.</code></pre>

<p><strong>tail</strong> - утилита, выводящая несколько последних строк файла, <strong>head</strong> - несколько первых строк.</p>

<p>Отображение последних 10 строк файла:</p>

<pre>
<code>$ tail -10 myfile  - отобразить последние 10 строк файла
$ tail -f myfile   - вывод новых строк файла в режиме реального времени можно использовать для просмотра обновления логов, остановить: ctrl-c
$ head -10 myfile1 - отобразить первые 10 строк файла</code></pre>

<p>По умолчанию <strong>tail</strong> выводит именно 10 последних строк.</p>

<p><strong>iconv </strong>- преобразование кодировки файла</p>

<pre>
<code>$ iconv -f &lt;начальная кодировка&gt; -t &lt;желаемая кодировка&gt; &lt;исходный файл&gt; -o &lt;файл-результат&gt;

Дополнительные ключи:

 -s  - игнорировать ошибки
 -l  - вывести список доступных кодировок
 -c  - отбросить неконвертируемые символы</code></pre>

<p><strong>Find</strong> &mdash; команда для поиска файлов и каталогов на основе специальных условий.</p>

<pre>
<code>$ find / -name top    - найти все файлы в системе, имеющие имя top
$ find / -iname top   - найти все файлы в системе, имеющие имя top без учета регистра символов
$ find / -name 'top*' - найти все файлы в системе с именами, начинающимися с top

$ find . -name "test*" -not -name "*.php" - найти файлы, начинающиеся на test, но без расширения php
$ find -name "*.html" -o -name "*.php"    - найти файлы с расширением html или php
$ find /usr/local -size +10000k           - найти файлы в /usr/local размером больше 10 килобайт
$ find ~ -size -300c                      - найти в домашнем каталоге размером меньше 300 байт
$ find . -exec ls -ld {} \;               - выполнить ls для получения подробной информации о каждом найденном файле
$ find /tmp -type f -name "*.txt" -exec rm -f {} \; - удалить все текстовые файлы в /tmp
</code></pre>

<p>Команда <strong>grep - </strong>поиск по шаблону в файле.</p>

<pre>
<code>$ grep шаблон *              - искать шаблон в файлах, находящихся в текущем каталоге
$ grep -r шаблон *           - искать шаблон в файлах текущего каталога и подкаталогов
$ grep -v -l pattern *       - найти файлы, не содержащие строк, соответствующих шаблону
$ grep -C 2 pattern files    - выведет строки, в которых найдено соответствие, плюс 2 строки до и 2 после каждой найденной
$ grep ERROR /var/log/app.log -c  - найти количество строк, содержащих ERROR в логе


$ grep -rnw '/path/to/somewhere/' -e 'pattern' - найти файлы, содержащие шаблон, расположенные в /path/to/somewhere/

-r or -R - искать рекурсивно по поддиректориям
-n       - выводить номера строк
-w       - искать целые слова в качестве совпадений
-l       - выводить только имена файлов

$ grep --include=\*.{c,h} -rnw '/path/to/somewhere/' -e "pattern"  - найти файлы, содержащие шаблон, расположенные в /path/to/somewhere/, имеющие расширение .c или .h

$ grep --exclude=*.o -rnw '/path/to/somewhere/' -e "pattern" - найти файлы, содержащие шаблон, расположенные в /path/to/somewhere/, кроме файлов с расширением .o

$ grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/somewhere/' -e "pattern" - найти файлы, содержащие шаблон, расположенные в /path/to/somewhere/, исключив из поиска директории dir1 и dir2 и файлы с расширением .dst
</code></pre>

<h2><a id="ch13">Информация о размерах файлов и директорий, свободном пространстве</a></h2>

<p>Для того, чтобы получить информацию о доступном в системе пространстве, можно использовать утилиту df (disk free):</p>

<pre>
<code class="language-bash">$ df -h     - показать в понятном формате (флаг h = human-readable) список всех файловых систем по именам устройств с указанием размера

</code></pre>

<p>Для оценки занимаемого файлом или директорией дискового пространства используется утилита du (disk usage):</p>

<pre>
<code class="language-bash">$ du -sh /home/myuser/data/      - отобразить размер директории
$ du -shx /home/myuser/data/     - отобразить размер директории, не учитывая каталоги в иерархии, относящиеся к другим точкам монтирования (флаг -x)
$ du -sh /home/myuser/data/      - отобразить размер директории и содержащихся в ней подкаталогов
$ du -sh /var/log/* | sort -hr   - отобразить размеры директории включая файлы внутри нее с сортировкой по занимаемому месту</code></pre>

<p>&nbsp;</p>

<h2><a id="ch9">Переменные окружения</a></h2>

<p>Переменные окружения в Linux - специальные переменные, определенные оболочкой и используемые программами во время выполнения. Могут быть определены как системой, так и пользователем.&nbsp;
    Переменные являются парамти ключ - строковое значение. Несколько значений разделяются двоеточием, если в значении присутствует пробел - нужно использовать кавычки.</p>

<pre>
<code class="language-bash">KEY=value1
KEY=value1:value2
KEY="value with spaces"</code></pre>

<p>Существует три типа переменных окружения:</p>

<p>&nbsp;- <strong>локальные переменные окружения</strong> (environmental variables) - определены только для текущей сессии, будут безвозвратно стерты по ее завершении. Вывести текущие переменные
    окружения - команда&nbsp;<strong>printenv&nbsp;</strong>или<strong>&nbsp;env&nbsp;</strong>без параметров</p>

<p>&nbsp;- <strong>пользовательские переменные окружения</strong> (shell variables) - определяются для конкретного пользователя и устанавливаются при входе в систему или удаленном подключении.
    Хранятся в файлах конфигурации&nbsp;&nbsp;.bashrc, .bash_profile, .bash_login,&nbsp;.profile и других, размещенных в директории пользователя. Для просмотра используется команда set.</p>

<p>&nbsp;-<strong> системные переменные окружения </strong>- доступны всем пользователям, загружаются при старте системы из файлов&nbsp;&nbsp;/etc/environment, /etc/profile, /etc/profile.d/
    /etc/bash.bashrc.</p>

<p>Конфигурационные файлы переменных окружения:</p>

<ul>
    <li>&nbsp;.bashrc - переменные конкретного пользователя, загружается каждый раз при создании пользователем терминального сеанса</li>
    <li>.bash_profile - загружается каждый раз при удаленном подключении по SSH</li>
    <li>/etc/environment - файл для работы с переменными окружения на системном уровне, будут доступны всем пользователям системы, в том числе при удаленном подключении</li>
    <li>/etc/bashrc - выполняется для всех локальных пользователей при создании сессии в терминале</li>
    <li>/etc/profile - выполняется для всех удаленных пользователей при открытии терминала</li>
</ul>

<p>Команды для работы с переменными окружения:</p>

<pre>
<code class="language-bash">$ echo $PATH                     - просмотр значения переменной
$ VAR=значение                   - установить пользовательскую переменную окружения для текущей сессии (недоступна дочерним процессам)
$ export VAR=значение            - установить локальную переменную окружения (environmental variable), доступную дочерним процессам
$ env –i [VAR=value] &lt;команда&gt;   - временно удалить все переменные оболочки и выполнить команду передав свои значения переменной
$ env –i bash                    - запустить оболочку без переменных окружения
$ unset VAR                      - удалить переменную по имени до конца текущей сессии
$ export PATH=""                 - альтернативный способ удалить переменную по имени до конца текущей сессии
$ PATH=$PATH:new_path            - добавить каталог в список путей, в которых shell ищет исполняемые файлы</code></pre>

<p>&nbsp;</p>

<h2><a id="ch10" name="ch10">Работа с сетью</a></h2>

<p>Основные команды для работы с сетью:</p>

<pre>
<code class="language-bash">$ ifconfig      - получение информации об активных сетевых устройствах
$ ifconfig -a   - получение информации обо всех сетевых устройствах
</code></pre>

<p>Адаптер lo (loopback) в выводе ifconfig используется системой для обращения к самой себе.</p>

<pre>
<code class="language-bash">$ ping -c 5 ya.ru            - отправить 5 пакетов ECHO_REQUEST по адресу ya.ru и отобразить задержку между отправкой пакета и ответом. Базовое средство проверки подключения компьютера к сети.
$ tracepath ya.ru            - проследить маршрут, по которому пакеты идут до хоста ya.ru
$ netstat -tnp               - отобразить установленные сетевые подключения. Опция -t отображает установленные tcp-соединения.
$ netstat -tln               - отобразить открытые приложениями порты (опция -l - показывать слушающие "listening"-порты)
$ netstat -tunap | grep 9090 - найти процессы, использующие порт 9090


Пример скрипта, ожидающего запуск Zookeeper на порту 2181:

# Wait until Zookeeper started
while [[ -z "`netstat -tln | grep 2181`" ]]; do
  sleep 1
done
echo 'Zookeeper started. Importing data...'

$ wget http://example.com/file.zip                      - скачать в текущую директорию file.zip
$ wget -P /path/to/save -O arch.zip http://example.com/file.zip     - скачать файл в директорию /path/to/save и сохранить под именем arch.zip
$ wget --save-cookies cookies.txt --post-data 'username=user&amp;password=pass' http://example.com/auth.php     - авторизоваться на сервере, передав логин и пароль и сохранить cookie в текстовый файл

curl http://test.com                      - получить содержание главной страницы сайта
curl -o index.html http://test.com        - сохранить содержимое главной страницы в index.html
curl -u user:pass http://test.com         - авторизоваться, используя HTTP Base Auth и получить содержимое страницы
curl -H 'Host: test.ru' http://test.com   - передать произвольные HTTP-заголовок
curl -X POST -H "Content-Type: application/json" -d '"name":"test"' http://test.com/api/ - передать POST-запрос с данными в JSON-формате
curl --request PUT "http://test.com/api/" --data "name=Test" - передать данные PUT-запросом
</code></pre>

<h2><a id="ch11" name="ch11">Работа со службами</a></h2>

<p>В RHEL7 для управления службами в операционной системе используется утилита systemd, приносящая концепцию юнитов.</p>

<p>Юниты находятся в конфигурационных файлах, расположенных в директориях (указаны по возрастанию приоритета):</p>

<ul>
    <li>/usr/lib/systemd/system/ - юниты из установленных покетов RPM</li>
    <li>/run/systemd/system/ - юниты, созданные в рантайме</li>
    <li>/etc/systemd/system/ -&nbsp;юниты, созданные и управляемые системным администратором с помощью команды&nbsp;<em>systemctl enable</em>.</li>
</ul>

<p>Юниты содержат информацию о системных сервисах, прослушиваемых сокетах, сохраненных снапшотах состояний системы и других обьектах, относящихся к системе инициализации.</p>

<p>Типы юнитов systemd:</p>

<ul>
    <li>.service&nbsp;&ndash; системный сервис,</li>
    <li>.target&nbsp;&mdash; группа юнитов systemd,</li>
    <li>.automount &ndash; точка автомонтирования файловой системы,</li>
    <li>.device&nbsp;&ndash; файл устройства, распознанного ядром,</li>
    <li>.mount&nbsp;&ndash; точка монтирования файловой системы,</li>
    <li>.path&nbsp;&ndash; файл или директория в файловой системе,</li>
    <li>.scope&nbsp;&ndash; процесс, созданный извне,</li>
    <li>.slice&nbsp;&ndash; группа иерархически организованных юнитов, управляющая системными процессами,</li>
    <li>.snapshot&nbsp;&ndash; сохраненное состояние менеджера systemd,</li>
    <li>.socket&nbsp;&ndash; сокет межпроцессного взаимодействия,</li>
    <li>.swap&nbsp;&ndash; свап-устройство или свап-файл (файл подкачки),</li>
    <li>.timer&nbsp;&ndash; таймер systemd.</li>
</ul>

<p>Основные команды для работы со службами:</p>

<pre>
<code class="language-bash">$ sudo systemctl start nginx.service       - запустить сервис
$ sudo systemctl stop nginx.service        - остановить сервис
$ sudo systemctl restart nginx.service     - перезапустить сервис
$ sudo systemctl reload nginx.service      - перечитать конф. файлы без перезапуска сервиса

$ sudo systemctl enable nginx.service      - включить автозапуск сервиса при загрузке системы
$ sudo systemctl disable nginx.service     - отключить автозапуск сервиса при загрузке системы

$ systemctl status nginx.service           - просмотр состояния сервиса

$ journalctl -u nginx.service              - вывод записей лог-файла сервиса

$ systemctl list-dependencies nginx.service  - отобразить дерево зависимостей юнита


$ systemctl cat nginx.service                - просмотреть юнит-файл
$ sudo systemctl edit --full nginx.service   - модифицировать юнит-файл
$ sudo systemctl daemon-reload               - перезапустить systemd для подхвата изменений после модификации юнит-файла</code></pre>

<h2><a id="ch12">Менеджер пакетов YUM</a></h2>

<p>Менеджер пакетов YUM - высокоуровневое решение по управлению RPM-пакетами.&nbsp; Основные преимущества YUM:</p>

<p>- хранение пакетов в централизованных репозиториях с определяющими зависимости метаданными. Если для установки одного пакета нужно докачать пакеты из других репозиториев - YUM будет об этом знать
    заранее</p>

<p>- автоматически разрешаются взаимосвязи между пакетами как при установке (докачать нужное) так и при удалении (удалить ставшее ненужным)</p>

<p>- возможность обновить одной командой все пакеты в системе</p>

<p>Основные комады YUM:</p>

<pre>
<code class="language-bash">$ yum repolist         - показать список сконфигурированных репозиториев
$ yum check-update     - проверка репозиториев на доступность обновлений
$ yum update           - обновление всех пакетов
$ yum update &lt;name&gt;    - обновление пакета &lt;name&gt;
$ yum install &lt;name&gt;   - установка пакета &lt;name&gt;
$ yum remove &lt;name&gt;    - удаление пакета &lt;name&gt;
$ yum clean packages   - удаление пакетов из кэша
$ yum clean all        - удаление из кэша и пакетов и метаданных


$ yum --showduplicates list &lt;name&gt; | expand        - отобразить все версии пакета &lt;name&gt;
$ sudo yum install &lt;name&gt;-&lt;version info&gt;           - установить нужную версию пакета &lt;name&gt;</code></pre>

<p>&nbsp;</p>

<h2><a id="ch8">Неразобранное, материал на будущее</a></h2>

<pre>
<code>$ mount    - просмотр примонтированных устройств
$ yum -y -q install cifs-utils              - устанавливаем cifs-utils
$ mkdir /mnt/shareddrive                    - создаем директорию, в которую будем монтировать
$ mount -t cifs //network/path /mnt/shareddrive -o 'rw,username=user,password='pass''  - монтируем сетевой диск в каталог /mnt/shareddrive, используем указанные имя пользователя и пароль для авторизации

$ ps -eL|wc -l  - определить количество процессов
$ cat /etc/security/limits.conf | grep nproc | grep username - определить максимальное количество процессов для пользователя
$ ps -eL|awk '{arr[$1]++}END{for (a in arr) print a, arr[a]}'|sort -nk 2 - определить процесс,который породил больше всего потоков
</code></pre>


    </article>
    <section class="post-nav" style="margin-bottom: 60px;">
        <div id="left-page">
            <div id="left-link">
                <a href="../"> </a>
            </div>
        </div>
        <div id="right-page">
            <div id="right-link">
                <a href="../posts/osnovy-analiza-bezopasnosti-veb-proektov/">Основы анализа безопасности веб-проектов </a>
                <div id="right-arrow"><i class="fa fa-chevron-circle-right"></i></div>
            </div>
        </div>
    </section>
    <div>
    </div>
</main>
    <footer>
        <h6>
            Copyright &copy 2017-2020
- ezhvsalate        </h6>
    </footer>
</div>
</body>
</html>
